let apSliderInstanceUid = 0; class APSlider extends HTMLElement { constructor() { super(), this.slides = this.children.length ? [...this.children] : [], this.settings = {}, this.dataSettings = JSON.parse(this.getAttribute("data-apslider")), this.noInit = this.getAttribute("data-no-init"), this.originalSlides = null, this.activeBreakpoint = null, this.animType = null, this.animProp = null, this.breakpoints = [], this.breakpointSettings = [], this.focussed = !1, this.interrupted = !1, this.hide = "hidden", this.paused = !0, this.positionProp = null, this.respondTo = null, this.rowCount = 1, this.shouldClick = !0, this.slidesCache = null, this.transformType = null, this.transitionType = null, this.visibilityChange = "visibilitychange", this.windowWidth = 0, this.windowTimer = null; } connectedCallback() { this.defaults = { accessibility: !0, adaptiveHeight: !1, appendArrows: this, appendDots: this, arrows: !0, asNavFor: null, autoplay: !1, autoplaySpeed: 3e3, centerMode: !1, centerPadding: "50px", cssEase: "ease", customPaging: function (e, t) { let i = this.createElement("button", null, { type: "button" }); return i.innerText = t + 1, i; }, dots: !0, dotsClass: "apslider-dots", draggable: !1, easing: "linear", edgeFriction: .35, fade: !1, focusOnSelect: !1, focusOnChange: !1, infinite: !1, initialSlide: 0, lazyLoad: "ondemand", mobileFirst: !1, pauseOnHover: !0, pauseOnFocus: !0, pauseOnDotsHover: !1, prevArrow: '<button class="apslider-prev" aria-label="Previous" type="button">Previous</button>', nextArrow: '<button class="apslider-next" aria-label="Next" type="button">Next</button>', respondTo: "window", responsive: null, rows: 1, rtl: !1, slide: "", slidesPerRow: 1, slidesToShow: 1, slidesToScroll: 1, speed: 500, swipe: !0, swipeToSlide: !1, touchMove: !0, touchThreshold: 5, variableWidth: !1, vertical: !1, verticalSwiping: !1, waitForAnimate: !0, zIndex: 1e3 }, this.initials = { animating: !1, dragging: !1, autoPlayTimer: null, currentDirection: 0, currentLeft: null, currentSlide: 0, direction: 1, dots: null, listWidth: null, listHeight: null, loadIndex: 0, prevArrow: null, nextArrow: null, scrolling: !1, slideCount: null, slideWidth: null, slideTrack: null, sliding: !1, slideOffset: 0, swipeLeft: null, swiping: !1, list: null, touchObject: {}, destroyed: !1 }, Object.assign(this, this.initials), this.options = { ...this.defaults, ...this.settings, ...this.dataSettings }, this.currentSlide = this.options.initialSlide, this.originalSettings = { ...this.options }, void 0 !== document.mozHidden ? (this.hide = "mozHidden", this.visibilityChange = "mozvisibilitychange") : void 0 !== document.webkitHidden && (this.hide = "webkitHidden", this.visibilityChange = "webkitvisibilitychange"), this.autoPlay = this.autoPlay.bind(this), this.autoPlayClear = this.autoPlayClear.bind(this), this.autoPlayIterator = this.autoPlayIterator.bind(this), this.changeSlide = this.changeSlide.bind(this), this.clickHandler = this.clickHandler.bind(this), this.selectHandler = this.selectHandler.bind(this), this.setPosition = this.setPosition.bind(this), this.swipeHandler = this.swipeHandler.bind(this), this.keyHandler = this.keyHandler.bind(this), this.instanceUid = apSliderInstanceUid++, this.htmlExpr = /^(?:\s*(<[\w\W]+>)[^>]*)$/, this.registerBreakpoints(), "true" !== this.noInit && this.init(!0); } toNodeList = e => { let t = document.createDocumentFragment(); return e.forEach(e => { t.appendChild(e.cloneNode()); }), t.childNodes; }; easeInOutQuad = e => (e /= .5) < 1 ? .5 * e * e : -.5 * (--e * (e - 2) - 1); animate = (e, t, i = 1e3, s = this.easeInOutQuad, o) => { let l = performance.now(), r = {}, n = Object.keys(t); function d(a) { let p = (a - l) / i; p > 1 && (p = 1); let c = s(p); n.forEach(function (i) { let s = parseFloat(r[i]), o = parseFloat(t[i]); e.style[i] = s + (o - s) * c + ("opacity" === i ? "" : "px"); }), p < 1 ? requestAnimationFrame(d) : "function" == typeof o && o(); } n.forEach(function (t) { r[t] = e.style[t]; }), requestAnimationFrame(d); }; cssAppender = (e, t) => { Object.keys(t).forEach(i => { e.style[i] = t[i]; }); }; init = e => { let t = this; if (t.slides.length) { if (t.classList.contains("apslider-initialized") || (t.classList.add("apslider"), t.classList.add("apslider-initialized"), t.getAttribute("data-no-init") && t.setAttribute("data-no-init", !1), t.destroyed = !1, !0 === t.options.variableWidth && (t.options.slidesToShow = t.options.slidesToShow < 2 ? 2 : t.options.slidesToShow), t.buildOut(), t.setProps(), t.startLoad(), t.loadSlider(), t.initializeEvents(), t.updateArrows(), t.updateDots(), t.checkResponsive(!0), t.focusHandler()), t.options.adaptiveHeight ? t.classList.add("apslider-adaptive-height") : t.classList.remove("apslider-adaptive-height"), e) { let i = new CustomEvent("init", { detail: { apslider: t } }); t.dispatchEvent(i); } !0 === t.options.accessibility && t.initADA(), t.options.autoplay && (t.paused = !1, t.autoPlay()); } }; addSlide = (e, t, i) => { let s = this; if ("boolean" == typeof t) i = t, t = null; else if (t < 0 || t >= s.slideCount) return !1; s.unload(), "number" == typeof t ? 0 === t && 0 === s.slides.length ? s.slideTrack.append(e) : i ? s.slides[t].before(e) : s.slides[t].after(e) : !0 === i ? s.slideTrack.prepand(e) : s.slideTrack.append(e), s.slides = s.options.slide ? [...s.slideTrack.querySelectorAll(s.options.slide)] : [...s.slideTrack.childNodes], s.slideTrack.childNodes.forEach(e => { e.remove(); }), s.slides.forEach(e => { s.slideTrack.appendChild(e); }), s.slides.forEach((e, t) => { e.setAttribute("data-slide-index", t); }), s.slidesCache = [...s.slides], s.reinit(); }; registerBreakpoints = () => { let e = this, t, i, s, o = e.options.responsive || null; if (Array.isArray(o) && o.length) { for (t in e.respondTo = e.options.respondTo || "window", o) if (s = e.breakpoints.length - 1, o.hasOwnProperty(t)) { for (i = o[t].breakpoint; s >= 0;)e.breakpoints[s] && e.breakpoints[s] === i && e.breakpoints.splice(s, 1), s--; e.breakpoints.push(i), e.breakpointSettings[i] = o[t].settings; } e.breakpoints.sort((t, i) => e.options.mobileFirst ? t - i : i - t); } }; focusHandler = () => { let e = this; function t(t) { t.stopImmediatePropagation(); let i = this; setTimeout(() => { e.options.pauseOnFocus && (e.focussed = i.matches(":focus"), e.autoPlay()); }, 0); } e.removeEventListener("focus", t), e.removeEventListener("blur", t), e.addEventListener("focus", t), e.addEventListener("blur", t); }; filterSlides = e => { let t = this; if (null !== e) { if (t.slidesCache = [...t.slides], t.originalSlides = [...t.slides], t.unload(), t.slideTrack.childNodes.forEach(e => { e.remove(); }), ":even" === e) t.slidesCache = [...t.slidesCache.filter((e, t) => t % 2 == 0)]; else if (":odd" === e) t.slidesCache = [...t.slidesCache.filter((e, t) => t % 2 != 0)]; else { let i = [...t.slidesCache.filter(t => t.classList.contains(e))]; t.slidesCache = [...i]; } t.slidesCache.forEach(e => { t.slideTrack.appendChild(e); }), t.reinit(!1, t.slidesCache); } }; getCurrentSlide = () => this.currentSlide; getOption = e => this.options[e]; goTo = (e, t) => { this.changeSlide({ data: { message: "index", index: parseInt(e) } }, t); }; unFilterSlides = () => { let e = this; null !== e.slidesCache && (e.unload(), e.slideTrack.childNodes.forEach(e => { e.remove(); }), e.slidesCache.forEach(t => { e.slideTrack.appendChild(t); }), e.reinit(!1, e.originalSlides)); }; unload = () => { this.querySelectorAll(".apslider-cloned").forEach(e => { e.remove(); }), this.dots && this.dots.remove(), this.prevArrow && this.htmlExpr.test(this.options.prevArrow) && this.prevArrow.remove(), this.nextArrow && this.htmlExpr.test(this.options.nextArrow) && this.nextArrow.remove(), this.slides.forEach(e => { e.classList.remove("apslider-slide"), e.classList.remove("apslider-active"), e.classList.remove("apslider-visible"), e.classList.remove("apslider-current"), e.setAttribute("aria-hidden", "true"), e.style.width = ""; }); }; interrupt = e => { let t = this; e || t.autoPlay(), t.interrupted = e; }; getAPSlider = () => this; refresh = e => { let t = this, i, s; s = t.slideCount - t.options.slidesToShow, !t.options.infinite && t.currentSlide > s && (t.currentSlide = s), t.slideCount <= t.options.slidesToShow && (t.currentSlide = 0), i = t.currentSlide, t.destroy(!0), Object.assign(t, t.initials, { currentSlide: i }), t.init(), e || t.changeSlide({ data: { message: "index", index: i } }, !1); }; cleanUpEvents = () => { let e = this; e.options.dots && null !== e.dots && (e.dots.querySelector("li").removeEventListener("click", e.changeSlide), e.dots.querySelector("li").removeEventListener("mouseenter", e.interrupt.bind(this, !0)), e.dots.querySelector("li").removeEventListener("mouseleave", e.interrupt.bind(this, !1)), !0 === e.options.accessibility && e.dots.removeEventListener("keydown", e.keyHandler)), !0 === e.options.arrows && e.slideCount > e.options.slidesToShow && (e.prevArrow && e.prevArrow.removeEventListener("click", e.changeSlide), e.nextArrow && e.nextArrow.removeEventListener("click", e.changeSlide), !0 === e.options.accessibility && (e.prevArrow && e.prevArrow.removeEventListener("keydown", e.keyHandler), e.nextArrow && e.nextArrow.removeEventListener("keydown", e.keyHandler))), e.list.removeEventListener("touchstart", e.swipeHandler), e.list.removeEventListener("mousedown", e.swipeHandler), e.list.removeEventListener("touchmove", e.swipeHandler), e.list.removeEventListener("mousemove", e.swipeHandler), e.list.removeEventListener("touchend", e.swipeHandler), e.list.removeEventListener("mouseup", e.swipeHandler), e.list.removeEventListener("touchcancel", e.swipeHandler), e.list.removeEventListener("mouseleave", e.swipeHandler), e.list.removeEventListener("click", e.clickHandler), document.removeEventListener(e.visibilityChange, e.visibility), e.cleanUpSlideEvents(), !0 === e.options.accessibility && e.list.removeEventListener("keydown", e.keyHandler), !0 === e.options.focusOnSelect && e.slideTrack.childNodes.forEach(t => { t.removeEventListener("click", e.selectHandler); }), window.removeEventListener("orientationchange", e.orientationChange), window.removeEventListener("resize", e.resize), e.slideTrack.querySelectorAll("[draggable]").forEach(t => { t.removeEventListener("dragstart", e.preventDefault); }), window.removeEventListener("load", e.setPosition); }; cleanUpSlideEvents = () => { this.list.removeEventListener("mouseenter", this.interrupt.bind(this, !0)), this.list.removeEventListener("mouseleave", this.interrupt.bind(this, !1)); }; destroy = (e, t) => { let i = this; if (i.autoPlayClear(), i.touchObject = {}, i.cleanUpEvents(), i.querySelectorAll(".apslider-cloned").forEach(e => { e.remove(); }), i.dots && i.dots.remove(), i.prevArrow && (i.prevArrow.classList.remove("apslider-disabled"), i.prevArrow.classList.remove("apslider-arrow"), i.prevArrow.classList.remove("apslider-hidden"), i.prevArrow.removeAttribute("aria-hidden"), i.prevArrow.removeAttribute("aria-disabled"), i.prevArrow.removeAttribute("tabindex"), i.prevArrow.style.display = "", i.htmlExpr.test(i.options.prevArrow) && i.prevArrow.remove()), i.nextArrow && (i.nextArrow.classList.remove("apslider-disabled"), i.nextArrow.classList.remove("apslider-arrow"), i.nextArrow.classList.remove("apslider-hidden"), i.nextArrow.removeAttribute("aria-hidden"), i.nextArrow.removeAttribute("aria-disabled"), i.nextArrow.removeAttribute("tabindex"), i.nextArrow.style.display = "", i.htmlExpr.test(i.options.nextArrow) && i.nextArrow.remove()), i.slides && (i.slides.forEach(e => { e.classList.remove("apslider-slide"), e.classList.remove("apslider-active"), e.classList.remove("apslider-center"), e.classList.remove("apslider-visible"), e.classList.remove("apslider-current"), e.removeAttribute("aria-hidden"), e.removeAttribute("data-slide-index"), e.style = e.dataset.originalStyling; }), i.slideTrack.childNodes.forEach(e => { e.remove(); }), i.slideTrack.remove(), i.list.remove(), i.slides.forEach(e => { i.append(e); })), i.cleanUpRows(), i.classList.remove("apslider-slider"), i.classList.remove("apslider-initialized"), i.classList.remove("apslider-dotted"), i.classList.remove("apslider"), i.getAttribute("data-no-init") && i.setAttribute("data-no-init", !0), i.destroyed = !0, !e) { let s = new CustomEvent("destroyed", { detail: { apslider: i, breakpoint: t } }); i.dispatchEvent(s); } }; cleanUpRows = () => { let e = this, t; if (e.options.rows > 0) { for ((t = [...e.slides]).forEach(e => { e.removeAttribute("style"); }); e.firstChild;)e.removeChild(e.firstChild); t.forEach(t => { e.appendChild(t); }); } }; initADA = () => { let e = this, t = Math.ceil(e.slideCount / e.options.slidesToShow), i = e.getNavigableIndexes().filter(t => t >= 0 && t < e.slideCount); if ([...e.slides, ...e.querySelectorAll(".apslider-cloned")].forEach(e => { e.setAttribute("aria-hidden", !0), e.setAttribute("tabindex", -1), e.querySelectorAll("a, input, button, select").forEach(e => { e.setAttribute("tabindex", -1); }); }), null !== e.dots) { let s = e.querySelectorAll(".apslider-slide:not(.apslider-cloned)"); s.forEach((t, s) => { let o = i.indexOf(s); if (t.setAttribute("role", "tabpanel"), t.setAttribute("id", `apslider-slide${e.instanceUid}${s}`), t.setAttribute("tabindex", -1), -1 !== o) { let l = `apslider-slide-control${e.instanceUid}${o}`; e.querySelectorAll(`#${l}`).length && t.setAttribute("aria-describedby", l); } }), e.dots.setAttribute("role", "tablist"), e.dots.querySelectorAll("li").forEach((s, o) => { let l = i[o]; s.setAttribute("role", "presentation"), s.querySelector("button").setAttribute("role", "tab"), s.querySelector("button").setAttribute("id", `apslider-slide-control${e.instanceUid}${o}`), s.querySelector("button").setAttribute("aria-controls", `apslider-slide${e.instanceUid}${l}`), s.querySelector("button").setAttribute("aria-label", `${o + 1} of ${t}`), s.querySelector("button").setAttribute("aria-selected", !1), s.querySelector("button").setAttribute("tabindex", -1), s.classList.contains("apslider-active") && (s.querySelector("button").setAttribute("aria-selected", !0), s.querySelector("button").setAttribute("tabindex", 0)); }); } for (let o = e.currentSlide, l = o + e.options.slidesToShow; o < l; o++)e.options.focusOnChange ? e.slides[o]?.setAttribute("tabindex", 0) : e.slides[o]?.removeAttribute("tabindex"); e.activateADA(); }; activateADA = () => { let e = this.slideTrack.querySelectorAll(".apslider-active"); e.forEach(e => { e.setAttribute("aria-hidden", !1), e.querySelectorAll("a, input, button, select").forEach(e => { e.setAttribute("tabindex", 0); }); }); }; checkResponsive = (e, t) => { let i = this, s, o, l, r = !1, n = i.clientWidth, d = window.innerWidth; if ("window" === i.respondTo ? l = d : "slider" === i.respondTo ? l = n : "min" === i.respondTo && (l = Math.min(d, n)), i.options.responsive && i.options.responsive.length && null !== i.options.responsive) { for (s in o = null, i.breakpoints) i.breakpoints.hasOwnProperty(s) && (!1 === i.originalSettings.mobileFirst ? l < i.breakpoints[s] && (o = i.breakpoints[s]) : l > i.breakpoints[s] && (o = i.breakpoints[s])); if (null !== o ? null !== i.activeBreakpoint ? (o !== i.activeBreakpoint || t) && (i.activeBreakpoint = o, "destroyed" === i.breakpointSettings[o] ? i.destroy(null, o) : (i.options = { ...i.originalSettings, ...i.breakpointSettings[o] }, !0 === e && (i.currentSlide = i.options.initialSlide), i.refresh(e)), r = o) : (i.activeBreakpoint = o, "destroyed" === i.breakpointSettings[o] ? i.destroy(null, o) : (i.options = { ...i.originalSettings, ...i.breakpointSettings[o] }, !0 === e && (i.currentSlide = i.options.initialSlide), i.refresh(e)), r = o) : null !== i.activeBreakpoint && (i.activeBreakpoint = null, i.options = { ...i.originalSettings }, !0 === e && (i.currentSlide = i.options.initialSlide), i.refresh(!0), r = o), !e && !1 !== r) { let a = new CustomEvent("breakpoint", { detail: { apslider: i, breakpoint: r } }); i.dispatchEvent(a); } } }; postSlide = e => { let t = this; if (!t.destroyed) { let i = new CustomEvent("afterChange", { detail: { apslider: t, currentSlide: e } }); if (t.dispatchEvent(i), t.animating = !1, t.slideCount > t.options.slidesToShow && t.setPosition(), t.swipeLeft = null, t.options.autoplay && t.autoPlay(), !0 === t.options.accessibility && (t.initADA(), t.options.focusOnChange)) { let s = t.slides.querySelector(t.slides[t.currentSlide]); s.setAttribute("tabindex", 0), s.focus(); } } }; setOption = (e, t, i) => { let s = this, o, l, r, n, d = !1, a; if ("object" == typeof e ? (r = e, d = t, a = "multiple") : "string" == typeof e && (r = e, n = t, d = i, "responsive" === e && "array" == typeof t ? a = "responsive" : void 0 !== t && (a = "single")), "single" === a) s.options[r] = n; else if ("multiple" === a) r.forEach((e, t) => { s.options[t] = e; }); else if ("responsive" === a) for (l in n) if ("array" != typeof s.options.responsive) s.options.responsive = [n[l]]; else { for (o = s.options.responsive.length - 1; o >= 0;)s.options.responsive[o].breakpoint === n[l].breakpoint && s.options.responsive.splice(o, 1), o--; s.options.responsive.push(n[l]); } d && (s.unload(), s.reinit()); }; changeSlide = (e, t) => { let i = e.currentTarget, s, o, l; switch (i?.matches("a") && e.preventDefault(), i?.matches("li") || (i = i?.closest("li")), s = (l = this.slideCount % this.options.slidesToScroll != 0) ? 0 : (this.slideCount - this.currentSlide) % this.options.slidesToScroll, e.data.message) { case "previous": o = 0 === s ? this.options.slidesToScroll : this.options.slidesToShow - s, this.slideCount > this.options.slidesToShow && this.slideHandler(this.currentSlide - o, !1, t); break; case "next": o = 0 === s ? this.options.slidesToScroll : s, this.slideCount > this.options.slidesToShow && this.slideHandler(this.currentSlide + o, !1, t); break; case "index": let r = 0 === e.data.index ? 0 : e.data.index || Array.prototype.slice.call(this.dots.querySelectorAll("li")).indexOf(i) * this.options.slidesToScroll; if (this.slideHandler(this.checkNavigable(r), !1, t), i) for (let n of i.childNodes) n.focus(); break; default: return; } }; checkNavigable = e => { let t, i; if (t = this.getNavigableIndexes(), i = 0, e > t[t.length - 1]) e = t[t.length - 1]; else for (let s in t) { if (e < t[s]) { e = i; break; } i = t[s]; } return e; }; getNavigableIndexes = () => { let e = 0, t = 0, i = [], s; for (!1 === this.options.infinite ? s = this.slideCount : (e = -1 * this.options.slidesToScroll, t = -1 * this.options.slidesToScroll, s = 2 * this.slideCount); e < s;)i.push(e), e = t + this.options.slidesToScroll, t += this.options.slidesToScroll <= this.options.slidesToShow ? this.options.slidesToScroll : this.options.slidesToShow; return i; }; slideHandler = (e, t, i) => { let s = this, o, l, r, n, d = null, a; if (t = t || !1, !0 === s.animating && !0 === s.options.waitForAnimate || !0 === s.options.fade && s.currentSlide === e) return; if (!1 === t && s.asNavFor(e), o = e, d = s.getLeft(o), n = s.getLeft(s.currentSlide), s.currentLeft = null === s.swipeLeft ? n : s.swipeLeft, !1 === s.options.infinite && !1 === s.options.centerMode && (e < 0 || e > s.getDotCount() * s.options.slidesToScroll) || !1 === s.options.infinite && !0 === s.options.centerMode && (e < 0 || e > s.slideCount - s.options.slidesToScroll)) { !1 === s.options.fade && (o = s.currentSlide, !0 !== i && s.slideCount > s.options.slidesToShow ? s.animateSlide(n, () => { s.postSlide(o); }) : s.postSlide(o)); return; } s.options.autoplay && clearInterval(s.autoPlayTimer), l = o < 0 ? s.slideCount % s.options.slidesToScroll != 0 ? s.slideCount - s.slideCount % s.options.slidesToScroll : s.slideCount + o : o >= s.slideCount ? s.slideCount % s.options.slidesToScroll != 0 ? 0 : o - s.slideCount : o, s.animating = !0; let p = new CustomEvent("beforeChange", { detail: { apslider: s, currentSlide: s.currentSlide, nextSlide: l } }); if (s.dispatchEvent(p), r = s.currentSlide, s.currentSlide = l, s.setSlideClasses(s.currentSlide), s.options.asNavFor && (a = s.getNavTarget()).forEach(e => { e.getAPSlider(), e.slideCount >= e.options.slidesToShow && e.setSlideClasses(s.currentSlide); }), s.updateDots(), s.updateArrows(), !0 === s.options.fade) { !0 !== i ? (s.fadeSlideOut(r), s.fadeSlide(l, () => { s.postSlide(l); })) : s.postSlide(l), s.animateHeight(); return; } !0 !== i && s.slideCount > s.options.slidesToShow ? s.animateSlide(d, () => { s.postSlide(l); }) : s.postSlide(l); }; next = () => { this.changeSlide({ data: { message: "next" } }); }; pause = () => { let e = this; e.autoPlayClear(), e.paused = !0; }; play = () => { let e = this; e.autoPlay(), e.options.autoplay = !0, e.paused = !1, e.focussed = !1, e.interrupted = !1; }; prev = () => { this.changeSlide({ data: { message: "previous" } }); }; preventDefault = e => { e.preventDefault(); }; reinit = (e, t) => { let i = this; e && (i.options = { ...i.options, ...i.settings }), i.slides = i.options.slide ? [...i.slideTrack.querySelectorAll(i.options.slide)] : t ? [...t] : [...i.slides], i.slideCount = i.slides.length, i.currentSlide >= i.slideCount && 0 !== i.currentSlide && (i.currentSlide = i.currentSlide - i.options.slidesToScroll), i.slideCount <= i.options.slidesToShow && (i.currentSlide = 0), i.registerBreakpoints(), i.setProps(), i.destroy(!0), i.init(!1); let s = new CustomEvent("reInit", { detail: { apslider: i } }); i.dispatchEvent(s); }; removeSlide = (e, t, i) => { let s = this; if (e = "boolean" == typeof e ? !0 === (t = e) ? 0 : s.slideCount - 1 : !0 === t ? --e : e, s.slideCount < 1 || e < 0 || e > s.slideCount - 1) return !1; s.unload(), !0 === i ? s.slideTrack.childNodes.forEach(e => { e.remove(); }) : s.options.slide ? s.slideTrack.querySelectorAll(s.options.slide)[e].remove() : s.slideTrack.childNodes[e].remove(), s.slides = s.options.slide ? [...s.slideTrack.querySelectorAll(s.options.slide)] : [...s.slideTrack.childNodes], s.slidesCache = [...s.slides], s.reinit(); }; animateHeight = () => { if (1 === this.options.slidesToShow && !0 === this.options.adaptiveHeight && !1 === this.options.vertical) { let e = this.slides[this.currentSlide].clientHeight; this.animate(this.list, { height: `${e}px` }, this.options.speed); } }; disableTransition = e => { let t = this, i = {}; i[t.transitionType] = "", !1 === t.options.fade ? t.cssAppender(t.slideTrack, i) : t.cssAppender(t.slides[e], i); }; fadeSlide = (e, t) => { let i = this; i.applyTransition(e), i.cssAppender(i.slides[e], { opacity: 1, zIndex: i.options.zIndex }), t && setTimeout(() => { i.disableTransition(e), t.call(); }, i.options.speed); }; fadeSlideOut = e => { this.applyTransition(e), this.cssAppender(this.slides[e], { opacity: 0, zIndex: this.options.zIndex - 2 }); }; applyTransition = e => { let t = this, i = {}; !1 === t.options.fade ? i[t.transitionType] = t.transformType + " " + t.options.speed + "ms " + t.options.cssEase : i[t.transitionType] = "opacity " + t.options.speed + "ms " + t.options.cssEase, !1 === t.options.fade ? t.cssAppender(t.slideTrack, i) : t.cssAppender(t.slides[e], i); }; animateSlide = (e, t) => { let i = this, s = {}; i.animateHeight(), !0 === i.options.rtl && !1 === i.options.vertical && (e = -e), i.applyTransition(), e = Math.ceil(e), !1 === i.options.vertical ? s[i.animType] = "translate3d(" + e + "px, 0px, 0px)" : s[i.animType] = "translate3d(0px," + e + "px, 0px)", i.cssAppender(i.slideTrack, s), t && setTimeout(() => { i.disableTransition(), t.call(); }, i.options.speed); }; keyHandler = e => { e.target.tagName.match("TEXTAREA|INPUT|SELECT") || (37 === e.keyCode && !0 === this.options.accessibility ? this.changeSlide({ data: { message: !0 === this.options.rtl ? "next" : "previous" } }) : 39 === e.keyCode && !0 === this.options.accessibility && this.changeSlide({ data: { message: !0 === this.options.rtl ? "previous" : "next" } })); }; selectHandler = e => { let t = e.target.classList.contains("apslider-slide") ? e.target : e.target.closest(".apslider-slide"), i = parseInt(t.getAttribute("data-slide-index")); if (i || (i = 0), this.slideCount <= this.options.slidesToShow) { this.slideHandler(i, !1, !0); return; } this.slideHandler(i); }; clickHandler = e => { !1 === this.shouldClick && (e.stopImmediatePropagation(), e.stopPropagation(), e.preventDefault()); }; swipeHandler = e => { let t = this, i = e.originalEvent ? e.originalEvent : e; if (!1 !== t.options.swipe && (!("ontouchend" in document) || !1 !== t.options.swipe)) { if (!1 !== t.options.draggable || -1 === i.type.indexOf("mouse")) switch (t.touchObject.fingerCount = i && void 0 !== i.touches ? i.touches.length : 1, t.touchObject.minSwipe = t.listWidth / t.options.touchThreshold, !0 === t.options.verticalSwiping && (t.touchObject.minSwipe = t.listHeight / t.options.touchThreshold), i.data.action) { case "start": t.swipeStart(i); break; case "move": t.swipeMove(i); break; case "end": t.swipeEnd(i); } } }; getSlideCount = () => { let e = this, t, i, s; return (s = !0 === e.options.centerMode ? e.slideWidth * Math.floor(e.options.slidesToShow / 2) : 0, !0 === e.options.swipeToSlide) ? (e.slideTrack.querySelectorAll(".apslider-slide").each((t, o) => { if (o.offsetLeft - s + e.querySelector(o).outerWidth() / 2 > -1 * e.swipeLeft) return i = o, !1; }), t = Math.abs(e.querySelector(i).getAttribute("data-slide-index") - e.currentSlide) || 1) : e.options.slidesToScroll; }; swipeDirection = () => { let e, t, i, s, o = this; return (e = o.touchObject.startX - o.touchObject.curX, (s = Math.round(180 * (i = Math.atan2(t = o.touchObject.startY - o.touchObject.curY, e)) / Math.PI)) < 0 && (s = 360 - Math.abs(s)), s <= 45 && s >= 0 || s <= 360 && s >= 315) ? !1 === o.options.rtl ? "left" : "right" : s >= 135 && s <= 225 ? !1 === o.options.rtl ? "right" : "left" : !0 === o.options.verticalSwiping ? s >= 35 && s <= 135 ? "down" : "up" : "vertical"; }; swipeEnd = e => { let t = this, i, s; if (t.dragging = !1, t.swiping = !1, t.scrolling) return t.scrolling = !1, !1; if (t.interrupted = !1, t.shouldClick = !(t.touchObject.swipeLength > 10), void 0 === t.touchObject.curX) return !1; if (!0 === t.touchObject.edgeHit) { let o = new CustomEvent("edge", { detail: { apslider: t, direction: t.swipeDirection() } }); t.dispatchEvent(o); } if (t.touchObject.swipeLength >= t.touchObject.minSwipe) { switch (s = t.swipeDirection()) { case "left": case "down": i = t.options.swipeToSlide ? t.checkNavigable(t.currentSlide + t.getSlideCount()) : t.currentSlide + t.getSlideCount(), t.currentDirection = 0; break; case "right": case "up": i = t.options.swipeToSlide ? t.checkNavigable(t.currentSlide - t.getSlideCount()) : t.currentSlide - t.getSlideCount(), t.currentDirection = 1; }if ("vertical" != s) { t.slideHandler(i), t.touchObject = {}; let l = new CustomEvent("swipe", { detail: { apslider: t, direction: s } }); t.dispatchEvent(l); } } else t.touchObject.startX !== t.touchObject.curX && (t.slideHandler(t.currentSlide), t.touchObject = {}); }; swipeMove = e => { let t = this, i = e.originalEvent ? e.originalEvent : e, s, o, l, r, n, d; return n = void 0 !== i ? i.touches : null, !!t.dragging && !t.scrolling && (!n || 1 === n.length) && ((s = t.getLeft(t.currentSlide), t.touchObject.curX = void 0 !== n ? n[0].pageX : i.clientX, t.touchObject.curY = void 0 !== n ? n[0].pageY : i.clientY, t.touchObject.swipeLength = Math.round(Math.sqrt(Math.pow(t.touchObject.curX - t.touchObject.startX, 2))), d = Math.round(Math.sqrt(Math.pow(t.touchObject.curY - t.touchObject.startY, 2))), t.options.verticalSwiping || t.swiping || !(d > 4)) ? (!0 === t.options.verticalSwiping && (t.touchObject.swipeLength = d), o = t.swipeDirection(), void 0 !== i && t.touchObject.swipeLength > 4 && (t.swiping = !0, i.preventDefault()), r = (!1 === t.options.rtl ? 1 : -1) * (t.touchObject.curX > t.touchObject.startX ? 1 : -1), !0 === t.options.verticalSwiping && (r = t.touchObject.curY > t.touchObject.startY ? 1 : -1), l = t.touchObject.swipeLength, t.touchObject.edgeHit = !1, !1 === t.options.infinite && (0 === t.currentSlide && "right" === o || t.currentSlide >= t.getDotCount() && "left" === o) && (l = t.touchObject.swipeLength * t.options.edgeFriction, t.touchObject.edgeHit = !0), !1 === t.options.vertical ? t.swipeLeft = s + l * r : t.swipeLeft = s + l * (t.list.clientHeight / t.listWidth) * r, !0 === t.options.verticalSwiping && (t.swipeLeft = s + l * r), !0 !== t.options.fade && !1 !== t.options.touchMove && (!0 === t.animating ? (t.swipeLeft = null, !1) : void t.setCSS(t.swipeLeft))) : (t.scrolling = !0, !1)); }; swipeStart = e => { let t = this, i = e.originalEvent ? e.originalEvent : e, s; if (t.interrupted = !0, 1 !== t.touchObject.fingerCount || t.slideCount <= t.options.slidesToShow) return t.touchObject = {}, !1; void 0 !== i && void 0 !== i.touches && (s = i.touches[0]), t.touchObject.startX = t.touchObject.curX = void 0 !== s ? s.pageX : i.clientX, t.touchObject.startY = t.touchObject.curY = void 0 !== s ? s.pageY : i.clientY, t.dragging = !0; }; initArrowEvents = () => { let e = this; !0 === e.options.arrows && e.slideCount > e.options.slidesToShow && (e.prevArrow.removeEventListener("click", e.changeSlide), e.prevArrow.addEventListener("click", t => { t.data = { message: "previous" }, e.changeSlide(t); }), e.nextArrow.removeEventListener("click", e.changeSlide), e.nextArrow.addEventListener("click", t => { t.data = { message: "next" }, e.changeSlide(t); }), !0 === e.options.accessibility && (e.prevArrow.addEventListener("keydown", e.keyHandler), e.nextArrow.addEventListener("keydown", e.keyHandler))); }; initDotEvents = () => { let e = this; !0 === e.options.dots && e.slideCount > e.options.slidesToShow && (e.dots.querySelectorAll("li").forEach(t => { t.addEventListener("click", t => { t.data = { message: "index" }, e.changeSlide(t); }); }), !0 === e.options.accessibility && e.dots.addEventListener("keydown", e.keyHandler)), !0 === e.options.dots && !0 === e.options.pauseOnDotsHover && e.slideCount > e.options.slidesToShow && e.dots.querySelectorAll("li").forEach(t => { t.addEventListener("mouseenter", e.interrupt.bind(e, !0)), t.addEventListener("mouseleave", e.interrupt.bind(e, !1)); }); }; initSlideEvents = () => { this.options.pauseOnHover && (this.list.addEventListener("mouseenter", this.interrupt.bind(this, !0)), this.list.addEventListener("mouseleave", this.interrupt.bind(this, !1))); }; visibility = () => { let e = this; e.options.autoplay && (document[e.hide] ? e.interrupted = !0 : e.interrupted = !1); }; initializeEvents = () => { let e = this; e.initArrowEvents(), e.initDotEvents(), e.initSlideEvents(), e.list.addEventListener("touchstart", t => { t.data = { action: "start" }, e.swipeHandler(t); }), e.list.addEventListener("mousedown", t => { t.data = { action: "start" }, e.swipeHandler(t); }), e.list.addEventListener("touchmove", t => { t.data = { action: "move" }, e.swipeHandler(t); }), e.list.addEventListener("mousemove", t => { t.data = { action: "move" }, e.swipeHandler(t); }), e.list.addEventListener("touchend", t => { t.data = { action: "end" }, e.swipeHandler(t); }), e.list.addEventListener("mouseup", t => { t.data = { action: "end" }, e.swipeHandler(t); }), e.list.addEventListener("touchcancel", t => { t.data = { action: "end" }, e.swipeHandler(t); }), e.list.addEventListener("mouseleave", t => { t.data = { action: "end" }, e.swipeHandler(t); }), e.list.addEventListener("click", e.clickHandler), this.addEventListener(e.visibilityChange, e.visibility.bind(e)), !0 === e.options.accessibility && e.list.addEventListener("keydown", e.keyHandler), !0 === e.options.focusOnSelect && e.slideTrack.childNodes.forEach(t => { t.addEventListener("click", e.selectHandler); }), window.addEventListener("orientationchange", e.orientationChange.bind(e)), window.addEventListener("resize", e.resize.bind(e)), e.slideTrack.querySelectorAll("[draggable]").forEach(t => { !0 != t.getAttribute("draggable") && t.addEventListener("dragstart", e.preventDefault); }), window.addEventListener("load", e.setPosition); }; orientationChange = () => { this.checkResponsive(), this.setPosition(); }; resize = () => { let e = this; window.innerWidth !== e.windowWidth && (clearTimeout(e.windowDelay), e.windowDelay = window.setTimeout(() => { e.windowWidth = window.innerWidth, e.checkResponsive(), e.destroyed || e.setPosition(); }, 50)); }; buildRows = () => { let e = this, t, i, s, o, l, r, n; if (o = document.createDocumentFragment(), r = Array.from(e.childNodes).slice(), e.options.rows > 0) { for (t = 0, n = e.options.slidesPerRow * e.options.rows, l = Math.ceil(r.length / n); t < l; t++) { let d = this.createElement("div"); for (i = 0; i < e.options.rows; i++) { let a = this.createElement("div"); for (s = 0; s < e.options.slidesPerRow; s++) { let p = t * n + (i * e.options.slidesPerRow + s); r.forEach(e => { e[p] && a.appendChild(e[p]); }); } d.appendChild(a); } o.appendChild(d); } for (; e.firstChild;)e.removeChild(e.firstChild); o.forEach(t => { e.appendChild(t); }), e.querySelectorAll(".apslider-slide").forEach(t => { e.cssAppender(t, { width: 100 / e.options.slidesPerRow + "%", display: "inline-block" }); }); } }; progressiveLazyLoad = e => { e = e || 1; let t = this, i = t.querySelectorAll("img[data-lazy]"), s, o, l, r, n; if (i.length) o = (s = i[0]).getAttribute("data-lazy"), l = s.getAttribute("data-srcset"), r = s.getAttribute("data-sizes") || t.getAttribute("data-sizes"), (n = t.createElement("img")).onload = () => { l && (s.setAttribute("srcset", l), r && s.setAttribute("sizes", r)), s.setAttribute("src", o), s.removeAttribute("data-lazy"), s.removeAttribute("data-srcset"), s.removeAttribute("data-sizes"), s.classList.remove("apslider-loading"), !0 === t.options.adaptiveHeight && t.setPosition(); let e = new CustomEvent("lazyLoaded", { detail: { apslider: t, image: s, imageSource: o } }); t.dispatchEvent(e), t.progressiveLazyLoad(); }, n.onerror = () => { if (e < 3) setTimeout(() => { t.progressiveLazyLoad(e + 1); }, 500); else { s.removeAttribute("data-lazy"), s.classList.remove("apslider-loading"), s.classList.add("apslider-lazyload-error"); let i = new CustomEvent("lazyLoadError", { detail: { apslider: t, image: s, imageSource: o } }); t.dispatchEvent(i), t.progressiveLazyLoad(); } }, n.src = o; else { let d = new CustomEvent("allImagesLoaded", { detail: { apslider: t } }); t.dispatchEvent(d); } }; lazyLoad = () => { let e = this, t, i, s, o; function l(t) { t.forEach(t => { if (t.querySelectorAll("img[data-lazy]").length) { let i = t.querySelectorAll("img"); i.forEach(t => { let i = t.getAttribute("data-lazy"), s = t.getAttribute("data-srcset"), o = t.getAttribute("data-sizes") || e.getAttribute("data-sizes"), l = e.createElement("img"); l.onload = () => { e.animate(t, { opacity: 0 }, 100, () => { s && (t.setAttribute("srcset", s), o && t.setAttribute("sizes", o)), t.setAttribute("src", i), e.animate(t, { opacity: 1 }, 200, () => { t.removeAttribute("data-lazy"), t.removeAttribute("data-srcset"), t.removeAttribute("data-sizes"), t.classList.remove("apslider-loading"); }); let l = new CustomEvent("lazyLoaded", { detail: { apslider: e, image: t, imageSource: i } }); e.dispatchEvent(l); }); }, l.onerror = () => { t.removeAttribute("data-lazy"), t.classList.remove("apslider-loading"), t.classList.add("apslider-lazyload-error"); let s = new CustomEvent("lazyLoadError", { detail: { apslider: e, image: t, imageSource: i } }); e.dispatchEvent(s); }, l.src = i; }); } }); } if (!0 === e.options.centerMode ? !0 === e.options.infinite ? o = (s = e.currentSlide + (e.options.slidesToShow / 2 + 1)) + e.options.slidesToShow + 2 : (s = Math.max(0, e.currentSlide - (e.options.slidesToShow / 2 + 1)), o = 2 + (e.options.slidesToShow / 2 + 1) + e.currentSlide) : (o = Math.ceil((s = e.options.infinite ? e.options.slidesToShow + e.currentSlide : e.currentSlide) + e.options.slidesToShow), !0 === e.options.fade && (s > 0 && s--, o <= e.slideCount && o++)), t = Array.from(e.querySelectorAll(".apslider-slide")).slice(s, o), "anticipated" === e.options.lazyLoad) { let r = s - 1, n = o, d = e.querySelectorAll(".apslider-slide"); for (let a = 0; a < e.options.slidesToScroll; a++)r < 0 && (r = e.slideCount - 1), t = [...t = [...t, d[r]], d[n]], r--, n++; } l(t), e.slideCount <= e.options.slidesToShow ? l(i = e.querySelectorAll(".apslider-slide")) : e.currentSlide >= e.slideCount - e.options.slidesToShow ? l(i = Array.from(e.querySelectorAll(".apslider-cloned")).slice(0, e.options.slidesToShow)) : 0 === e.currentSlide && l(i = Array.from(e.querySelectorAll(".apslider-cloned")).slice(-1 * e.options.slidesToShow)); }; setSlideClasses = e => { let t, i, s, o; if (i = Array.from(this.querySelectorAll(".apslider-slide")).map(e => (e.classList.remove("apslider-active"), e.classList.remove("apslider-center"), e.classList.remove("apslider-current"), e.setAttribute("aria-hidden", "true"), e)), this.slides[e].classList.add("apslider-current"), !0 === this.options.centerMode) { let l = this.options.slidesToShow % 2 == 0 ? 1 : 0; if (t = Math.floor(this.options.slidesToShow / 2), !0 === this.options.infinite) { if (e >= t && e <= this.slideCount - 1 - t) { let r = this.slides.slice(e - t + l, e + t + 1); r.forEach(e => { e.classList.add("apslider-active"), e.setAttribute("aria-hidden", "false"); }); } else { s = this.options.slidesToShow + e; let n = i.slice(s - t + 1 + l, s + t + 2); n.forEach(e => { e.classList.add("apslider-active"), e.setAttribute("aria-hidden", "false"); }); } 0 === e ? i[i.length - 1 - this.options.slidesToShow].classList.add("apslider-center") : e === this.slideCount - 1 && i[this.options.slidesToShow].classList.add("apslider-center"); } this.slides[e].classList.add("apslider-center"); } else if (e >= 0 && e <= this.slideCount - this.options.slidesToShow) { let d = this.slides.slice(e, e + this.options.slidesToShow); d.forEach(e => { e.classList.add("apslider-active"), e.setAttribute("aria-hidden", "false"); }); } else if (i.length <= this.options.slidesToShow) i.forEach(e => { e.classList.add("apslider-active"), e.setAttribute("aria-hidden", "false"); }); else if (o = this.slideCount % this.options.slidesToShow, s = !0 === this.options.infinite ? this.options.slidesToShow + e : e, this.options.slidesToShow == this.options.slidesToScroll && this.slideCount - e < this.options.slidesToShow) { let a = i.slice(s - (this.options.slidesToShow - o), s + o); a.forEach(e => { e.classList.add("apslider-active"), e.setAttribute("aria-hidden", "false"); }); } else { let p = i.slice(s, s + this.options.slidesToShow); p.forEach(e => { e.classList.add("apslider-active"), e.setAttribute("aria-hidden", "false"); }); } ("ondemand" === this.options.lazyLoad || "anticipated" === this.options.lazyLoad) && this.lazyLoad(); }; initUI = () => { let e = this; !0 === e.options.arrows && e.slideCount > e.options.slidesToShow && (e.prevArrow.style.display = "block", e.nextArrow.style.display = "block"), !0 === e.options.dots && e.slideCount > e.options.slidesToShow && (e.dots.style.display = "block"); }; getLeft = e => { let t = this, i, s, o = 0, l, r; return t.slideOffset = 0, s = t.slides[0].clientHeight, !0 === t.options.infinite ? (t.slideCount > t.options.slidesToShow && (t.slideOffset = -(t.slideWidth * t.options.slidesToShow * 1), r = -1, !0 === t.options.vertical && !0 === t.options.centerMode && (2 === t.options.slidesToShow ? r = -1.5 : 1 === t.options.slidesToShow && (r = -2)), o = s * t.options.slidesToShow * r), t.slideCount % t.options.slidesToScroll != 0 && e + t.options.slidesToScroll > t.slideCount && t.slideCount > t.options.slidesToShow && (e > t.slideCount ? (t.slideOffset = -((t.options.slidesToShow - (e - t.slideCount)) * t.slideWidth * 1), o = -((t.options.slidesToShow - (e - t.slideCount)) * s * 1)) : (t.slideOffset = -(t.slideCount % t.options.slidesToScroll * t.slideWidth * 1), o = -(t.slideCount % t.options.slidesToScroll * s * 1)))) : e + t.options.slidesToShow > t.slideCount && (t.slideOffset = (e + t.options.slidesToShow - t.slideCount) * t.slideWidth, o = (e + t.options.slidesToShow - t.slideCount) * s), t.slideCount <= t.options.slidesToShow && (t.slideOffset = 0, o = 0), !0 === t.options.centerMode && t.slideCount <= t.options.slidesToShow ? t.slideOffset = t.slideWidth * Math.floor(t.options.slidesToShow) / 2 - t.slideWidth * t.slideCount / 2 : !0 === t.options.centerMode && !0 === t.options.infinite ? t.slideOffset += t.slideWidth * Math.floor(t.options.slidesToShow / 2) - t.slideWidth : !0 === t.options.centerMode && (t.slideOffset = 0, t.slideOffset += t.slideWidth * Math.floor(t.options.slidesToShow / 2)), !0 === t.options.centerMode && (t.slideOffset -= parseInt(t.options.centerPadding)), i = !1 === t.options.vertical ? -(e * t.slideWidth * 1) + t.slideOffset : -(e * s * 1) + o, !0 === t.options.variableWidth && (l = t.slideCount <= t.options.slidesToShow || !1 === t.options.infinite ? t.slideTrack.querySelectorAll(".apslider-slide")[e] : t.slideTrack.querySelectorAll(".apslider-slide")[e + t.options.slidesToShow], i = !0 === t.options.rtl ? l[0] ? -((t.slideTrack.getBoundingClientRect().width - l[0].offsetLeft - l.getBoundingClientRect().width) * 1) : 0 : l ? -1 * l.offsetLeft : 0, !0 === t.options.centerMode && (l = t.slideCount <= t.options.slidesToShow || !1 === t.options.infinite ? t.slideTrack.querySelectorAll(".apslider-slide")[e] : t.slideTrack.querySelectorAll(".apslider-slide")[e + t.options.slidesToShow + 1], i = !0 === t.options.rtl ? l[0] ? -((t.slideTrack.getBoundingClientRect().width - l[0].offsetLeft - l.getBoundingClientRect().width) * 1) : 0 : l ? -1 * l.offsetLeft : 0, i += (t.list.getBoundingClientRect().width - l.clientWidth) / 2)), i; }; setCSS = e => { let t = this, i = {}, s, o; !0 === t.options.rtl && (e = -e), s = "left" == t.positionProp ? Math.ceil(e) + "px" : "0px", o = "top" == t.positionProp ? Math.ceil(e) + "px" : "0px", i[t.positionProp] = e, (i = {})[t.animType] = "translate3d(" + s + ", " + o + ", 0px)", t.cssAppender(t.slideTrack, i); }; setFade = () => { let e = this, t; e.slides.forEach((i, s) => { t = -(e.slideWidth * s * 1), !0 === e.options.rtl ? e.cssAppender(i, { position: "relative", right: `${t}px`, top: "0", zIndex: e.options.zIndex - 2, opacity: "0" }) : e.cssAppender(i, { position: "relative", left: `${t}px`, top: "0", zIndex: e.options.zIndex - 2, opacity: "0" }); }), e.cssAppender(e.slides[e.currentSlide], { zIndex: e.options.zIndex - 1, opacity: "1" }); }; asNavFor = e => { let t = this.getNavTarget(); null !== t && "object" == typeof t && t.forEach(t => { let i = t.getAPSlider(); i.destroyed || i.slideHandler(e, !0); }); }; getNavTarget = () => { let e = this.options.asNavFor; return e && null !== e && (e = document.querySelectorAll(e)), e; }; setDimensions = () => { let e = this; !1 === e.options.vertical ? !0 === e.options.centerMode && e.cssAppender(e.list, { padding: "0px " + e.options.centerPadding }) : (e.list.style.height = e.slides[0].clientHeight * e.options.slidesToShow + "px", !0 === e.options.centerMode && e.cssAppender(e.list, { padding: e.options.centerPadding + " 0px" })), e.listWidth = e.list.getBoundingClientRect().width, e.listHeight = e.list.getBoundingClientRect().height, !1 === e.options.vertical && !1 === e.options.variableWidth ? (e.slideWidth = Math.ceil(e.listWidth / e.options.slidesToShow), e.slideTrack.style.width = Math.ceil(e.slideWidth * e.slideTrack.querySelectorAll(".apslider-slide").length) + "px") : !0 === e.options.variableWidth ? e.slideTrack.style.width = 5e3 * e.slideCount + "px" : (e.slideWidth = Math.ceil(e.listWidth), e.slideTrack.style.height = Math.ceil(e.slides[0].clientHeight * e.slideTrack.querySelectorAll(".apslider-slide").length) + "px"); let t = e.slides[0].clientWidth - e.slides[0].getBoundingClientRect().width; !1 === e.options.variableWidth && e.slideTrack.querySelectorAll(".apslider-slide").forEach(i => { i.style.width = e.slideWidth - t + "px"; }); }; setHeight = () => { let e = this; if (1 === e.options.slidesToShow && !0 === e.options.adaptiveHeight && !1 === e.options.vertical) { let t = e.slides[e.currentSlide].clientHeight; e.list.style.height = t + "px"; } }; setPosition = () => { this.setDimensions(), this.setHeight(), !1 === this.options.fade ? this.setCSS(this.getLeft(this.currentSlide)) : this.setFade(); let e = new CustomEvent("setPosition", { detail: { apslider: this } }); this.dispatchEvent(e); }; loadSlider = () => { let e = this; e.setPosition(), e.slideTrack.style.opacity = 1, e.classList.remove("apslider-loading"), e.initUI(), "progressive" === e.options.lazyLoad && e.progressiveLazyLoad(); }; startLoad = () => { let e = this; !0 === e.options.arrows && e.slideCount > e.options.slidesToShow && (e.prevArrow.style.display = "none", e.nextArrow.style.display = "none"), !0 === e.options.dots && e.slideCount > e.options.slidesToShow && (e.dots.style.display = "none"), e.classList.add("apslider-loading"); }; setProps = () => { let e = this; document.body.style, e.positionProp = !0 === e.options.vertical ? "top" : "left", "top" === e.positionProp ? e.classList.add("apslider-vertical") : e.classList.remove("apslider-vertical"), e.options.fade && ("number" == typeof e.options.zIndex ? e.options.zIndex < 3 && (e.options.zIndex = 3) : e.options.zIndex = e.defaults.zIndex), e.animType = "transform", e.transformType = "transform", e.transitionType = "transition"; }; getDotCount = () => { let e = 0, t = 0, i = 0; if (!0 === this.options.infinite) { if (this.slideCount <= this.options.slidesToShow) ++i; else for (; e < this.slideCount;)++i, e = t + this.options.slidesToScroll, t += this.options.slidesToScroll <= this.options.slidesToShow ? this.options.slidesToScroll : this.options.slidesToShow; } else if (!0 === this.options.centerMode) i = this.slideCount; else if (this.options.asNavFor) for (; e < this.slideCount;)++i, e = t + this.options.slidesToScroll, t += this.options.slidesToScroll <= this.options.slidesToShow ? this.options.slidesToScroll : this.options.slidesToShow; else i = 1 + Math.ceil((this.slideCount - this.options.slidesToShow) / this.options.slidesToScroll); return i - 1; }; createElement = (e, t, i) => { let s = document.createElement(e); if (t && s.classList.add(...t.split(",")), i) for (let o in i) Object.prototype.hasOwnProperty.call(i, o) && (o.includes("data-") || (s[o] = i[o]), o.includes("data-") && s.setAttribute(o, i[o])); return s; }; autoPlay = () => { let e = this; e.autoPlayClear(), e.slideCount > e.options.slidesToShow && (e.autoPlayTimer = setInterval(e.autoPlayIterator, e.options.autoplaySpeed)); }; autoPlayIterator = () => { let e = this, t = e.currentSlide + e.options.slidesToScroll; e.paused || e.interrupted || e.focussed || (!1 === e.options.infinite && (1 === e.direction && e.currentSlide + 1 === e.slideCount - 1 ? e.direction = 0 : 0 === e.direction && (t = e.currentSlide - e.options.slidesToScroll, e.currentSlide - 1 == 0 && (e.direction = 1))), e.slideHandler(t)); }; autoPlayClear = () => { this.autoPlayTimer && clearInterval(this.autoPlayTimer); }; setupInfinite = () => { let e = this, t, i, s; if (!0 === e.options.fade && (e.options.centerMode = !1), !0 === e.options.infinite && !1 === e.options.fade && (i = null, e.slideCount > e.options.slidesToShow)) { if (s = !0 === e.options.centerMode ? e.options.slidesToShow + 1 : e.options.slidesToShow, e.slideTrack.querySelectorAll(".apslider-cloned").length < 1) { for (t = e.slideCount; t > e.slideCount - s; t -= 1) { i = t - 1; let o = e.slides[i].cloneNode(!0); o.classList.add("apslider-cloned"), o.setAttribute("id", ""), o.setAttribute("data-slide-index", i - e.slideCount), e.slideTrack.prepend(o); } for (t = 0; t < s; t += 1) { i = t; let l = e.slides[i].cloneNode(!0); l.classList.add("apslider-cloned"), l.setAttribute("id", ""), l.setAttribute("data-slide-index", i + e.slideCount), e.slideTrack.append(l); } } e.slideTrack.querySelectorAll(".apslider-cloned").forEach(e => { e.setAttribute("id", ""); }); } }; updateDots = () => { null !== this.dots && (this.dots.querySelectorAll("li").forEach(e => { e.classList.remove("apslider-active"); }), this.dots.querySelectorAll("li")[Math.floor(this.currentSlide / this.options.slidesToScroll)].classList.add("apslider-active")); }; buildDots = () => { let e = this; if (!0 === e.options.dots && e.slideCount > e.options.slidesToShow) { e.classList.add("apslider-dotted"); let t = e.createElement("ul", e.options.dotsClass); for (let i = 0; i <= e.getDotCount(); i += 1) { let s = e.createElement("li"); s.appendChild(e.options.customPaging.call(this, e, i)), t.appendChild(s); } e.dots = e.options.appendDots.appendChild(t), e.dots.querySelectorAll("li")[0].classList.add("apslider-active"), e.style.setProperty("--dotsHeight", `${e.dots.getBoundingClientRect().height}px`); } }; updateArrows = () => { !0 === this.options.arrows && this.slideCount > this.options.slidesToShow && !this.options.infinite && (this.prevArrow.classList.remove("apslider-disabled"), this.prevArrow.setAttribute("aria-disabled", "false"), this.nextArrow.classList.remove("apslider-disabled"), this.nextArrow.setAttribute("aria-disabled", "false"), 0 === this.currentSlide ? (this.prevArrow.classList.add("apslider-disabled"), this.prevArrow.setAttribute("aria-disabled", "true"), this.nextArrow.classList.remove("apslider-disabled"), this.nextArrow.setAttribute("aria-disabled", "false")) : this.currentSlide >= this.slideCount - this.options.slidesToShow && !1 === this.options.centerMode ? (this.nextArrow.classList.add("apslider-disabled"), this.nextArrow.setAttribute("aria-disabled", "true"), this.prevArrow.classList.remove("apslider-disabled"), this.prevArrow.setAttribute("aria-disabled", "false")) : this.currentSlide >= this.slideCount - 1 && !0 === this.options.centerMode && (this.nextArrow.classList.add("apslider-disabled"), this.nextArrow.setAttribute("aria-disabled", "true"), this.prevArrow.classList.remove("apslider-disabled"), this.prevArrow.setAttribute("aria-disabled", "false"))); }; buildArrows = () => { let e = this; e.options.arrows && (e.prevArrow = e.createElement("span"), e.nextArrow = e.createElement("span"), e.prevArrow.innerHTML = e.options.prevArrow, e.nextArrow.innerHTML = e.options.nextArrow, e.prevArrow = e.prevArrow.firstChild, e.nextArrow = e.nextArrow.firstChild, e.prevArrow.classList.add("apslider-arrow"), e.nextArrow.classList.add("apslider-arrow"), e.slideCount > e.options.slidesToShow ? (e.prevArrow.classList.remove("apslider-hidden"), e.prevArrow.removeAttribute("aria-hidden"), e.prevArrow.removeAttribute("tabindex"), e.nextArrow.classList.remove("apslider-hidden"), e.nextArrow.removeAttribute("aria-hidden"), e.nextArrow.removeAttribute("tabindex"), e.htmlExpr.test(e.options.prevArrow) && e.prepend(e.prevArrow), e.htmlExpr.test(e.options.nextArrow) && e.append(e.nextArrow), !0 !== e.options.infinite && (e.prevArrow.classList.add("apslider-disabled"), e.prevArrow.setAttribute("aria-disabled", !0))) : (e.prevArrow.classList.add("apslider-hidden"), e.prevArrow.setAttribute("aria-hidden", !0), e.prevArrow.setAttribute("tabindex", "-1"), e.nextArrow.classList.add("apslider-hidden"), e.nextArrow.setAttribute("aria-hidden", !0), e.nextArrow.setAttribute("tabindex", "-1"))); }; buildOut = () => { let e = this, t = e.createElement("div", "apslider-track,slides", { role: "listbox" }), i = e.createElement("div", "apslider-list", { ariaLive: "polite" }); e.slideCount = e.slides.length, e.slides.forEach((e, i) => { e.classList.add("apslider-slide"), e.setAttribute("data-slide-index", i), e.dataset.originalStyling = e.getAttribute("style") || "", t.appendChild(e); }), i.appendChild(t), e.appendChild(i), e.classList.add("apslider-slider"), e.slideTrack = t, e.list = i, t.style.opacity = 0, (!0 === e.options.centerMode || !0 === e.options.swipeToSlide) && (e.options.slidesToScroll = 1), e.querySelectorAll("img[data-lazy]:not([src])").forEach(e => { e.classList.add("apslider-loading"); }), e.setupInfinite(), e.buildArrows(), e.buildDots(), e.updateDots(), e.setSlideClasses("number" == typeof e.currentSlide ? e.currentSlide : 0), !0 === e.options.draggable && e.list.classList.add("draggable"); }; } customElements.define("ap-slider", APSlider);